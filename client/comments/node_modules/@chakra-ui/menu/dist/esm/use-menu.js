function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { useClickable } from "@chakra-ui/clickable";
import { useDescendant, useDescendants } from "@chakra-ui/descendant";
import { useControllableState, useDisclosure, useId, useIds, useShortcut, useUpdateEffect } from "@chakra-ui/hooks";
import { usePopper } from "@chakra-ui/popper";
import { addItem, callAllHandlers, createContext, cx, dataAttr, focus, getNextIndex, getNextItemFromSearch, getPrevIndex, getValidChildren, isArray, isString, mergeRefs, normalizeEventKey, removeItem } from "@chakra-ui/utils";
import { useInteractOutside } from "@react-aria/interactions";
import { cloneElement, useCallback, useRef, useState } from "react";
var [MenuProvider, useMenuContext] = createContext({
  strict: false,
  name: "MenuContext"
});
export { MenuProvider, useMenuContext };

/**
 * React Hook to manage a menu
 *
 * It provides the logic and will be used with react context
 * to propagate it's return value to all children
 */
export function useMenu(props) {
  var {
    id,
    closeOnSelect = true,
    closeOnBlur = true,
    autoSelect = true,
    placement: placementProp = "bottom-start",
    gutter,
    fixed = true,
    preventOverflow,
    modifiers,
    isLazy
  } = props;
  var {
    isOpen,
    onOpen,
    onClose,
    onToggle
  } = useDisclosure(props);
  /**
   * Prepare the reference to the menu and disclosure
   */

  var menuRef = useRef(null);
  var buttonRef = useRef(null);
  useInteractOutside({
    ref: menuRef,
    onInteractOutside: event => {
      var _buttonRef$current;

      if (isOpen && closeOnBlur && !((_buttonRef$current = buttonRef.current) == null ? void 0 : _buttonRef$current.contains(event.target))) {
        onClose();
      }
    }
  });
  /**
   * Add some popper.js for dynamic positioning
   */

  var {
    placement,
    popper,
    reference
  } = usePopper({
    placement: placementProp,
    fixed,
    forceUpdate: isOpen,
    gutter,
    preventOverflow,
    modifiers
  });
  var [focusedIndex, setFocusedIndex] = useState(-1);
  /**
   * Context to register all menu item nodes
   */

  var domContext = useDescendants();
  /**
   * Focus the button when we close the menu
   */

  useUpdateEffect(() => {
    if (!isOpen) {
      setFocusedIndex(-1);

      if (buttonRef.current) {
        focus(buttonRef.current, {
          preventScroll: true
        });
      }
    }
  }, [isOpen]);
  /**
   * Generate unique ids for menu's list and button
   */

  var [buttonId, menuId] = useIds(id, "menu-button", "menu-list");
  return {
    domContext,
    popper,
    placement,
    reference,
    buttonId,
    menuId,
    orientation: "vertical",
    isOpen,
    onToggle,
    onOpen,
    onClose,
    menuRef,
    buttonRef,
    focusedIndex,
    closeOnSelect,
    closeOnBlur,
    autoSelect,
    setFocusedIndex,
    isLazy
  };
}
export function useMenuList(props) {
  var menu = useMenuContext();

  if (!menu) {
    throw new Error("useMenuContext: context is undefined. Seems you forgot the component within <Menu>");
  }

  var {
    focusedIndex,
    setFocusedIndex,
    menuRef,
    isOpen,
    onClose,
    popper,
    menuId,
    placement,
    domContext: {
      descendants
    },
    isLazy
  } = menu;
  /**
   * Hook that creates a keydown event handler that listens
   * to printable keyboard character press
   */

  var onCharacterPress = useShortcut({
    preventDefault: event => event.key !== " "
  });
  var onKeyDown = useCallback(event => {
    var eventKey = normalizeEventKey(event);
    var keyMap = {
      Escape: onClose,
      ArrowDown: () => {
        var nextIndex = getNextIndex(focusedIndex, descendants.length);
        setFocusedIndex(nextIndex);
      },
      ArrowUp: () => {
        var prevIndex = getPrevIndex(focusedIndex, descendants.length);
        setFocusedIndex(prevIndex);
      }
    };
    var action = keyMap[eventKey];

    if (action) {
      event.preventDefault();
      action(event);
    } else {
      var _action = onCharacterPress(character => {
        /**
         * Typeahead: Based on current character pressed,
         * find the next item to be selected
         */
        var nextItem = getNextItemFromSearch(descendants, character, node => {
          var _node$element;

          return ((_node$element = node.element) == null ? void 0 : _node$element.textContent) || "";
        }, descendants[focusedIndex]);

        if (nextItem) {
          var index = descendants.indexOf(nextItem);
          setFocusedIndex(index);
        }
      });

      _action(event);
    }
  }, [descendants, focusedIndex, onCharacterPress, onClose, setFocusedIndex]);
  return _extends({}, props, {
    children: !isLazy || isOpen ? props.children : null,
    className: cx("chakra-menu__menu-list", props.className),
    ref: mergeRefs(menuRef, popper.ref),
    tabIndex: -1,
    role: "menu",
    id: menuId,
    hidden: !isOpen,
    "aria-orientation": "vertical",
    "data-placement": placement,
    style: _extends({}, popper.style, props.style),
    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)
  });
}
/**
 * React Hook to manage a menu button.
 *
 * The assumption here is that the `useMenu` hook is used
 * in a component higher up the tree, and it's return value
 * is passed as `context` to this hook.
 */

export function useMenuButton(props) {
  var menu = useMenuContext();
  var {
    setFocusedIndex,
    onOpen,
    isOpen,
    onClose,
    autoSelect,
    menuRef,
    domContext: {
      descendants
    }
  } = menu;
  var openAndFocusMenu = useCallback(() => {
    onOpen();

    if (menuRef.current) {
      focus(menuRef.current);
    }
  }, [onOpen, menuRef]);
  var openAndFocusFirstItem = useCallback(() => {
    onOpen();
    setFocusedIndex(0);
  }, [onOpen, setFocusedIndex]);
  var openAndFocusLastItem = useCallback(() => {
    onOpen();
    var lastIndex = descendants.length - 1;
    setFocusedIndex(lastIndex);
  }, [onOpen, setFocusedIndex, descendants]);
  var onClick = useCallback(() => {
    if (isOpen) {
      onClose();
    } else {
      var action = autoSelect ? openAndFocusFirstItem : openAndFocusMenu;
      action();
    }
  }, [autoSelect, isOpen, onClose, openAndFocusFirstItem, openAndFocusMenu]);
  var onKeyDown = useCallback(event => {
    var eventKey = normalizeEventKey(event);
    var keyMap = {
      Enter: openAndFocusFirstItem,
      ArrowDown: openAndFocusFirstItem,
      ArrowUp: openAndFocusLastItem
    };
    var action = keyMap[eventKey];

    if (action) {
      event.preventDefault();
      event.stopPropagation();
      action(event);
    }
  }, [openAndFocusFirstItem, openAndFocusLastItem]);
  return _extends({}, props, {
    ref: mergeRefs(menu.buttonRef, menu.reference.ref),
    className: cx("chakra-menu__menu-button", props.className),
    id: menu.buttonId,
    "data-active": dataAttr(menu.isOpen),
    "aria-expanded": menu.isOpen,
    "aria-haspopup": "menu",
    "aria-controls": menu.menuId,
    onClick: callAllHandlers(props.onClick, onClick),
    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)
  });
}
export function useMenuItem(props) {
  var {
    onClick: onClickProp,
    isDisabled,
    isFocusable
  } = props,
      htmlProps = _objectWithoutPropertiesLoose(props, ["onMouseOut", "onClick", "isDisabled", "isFocusable"]);

  var menu = useMenuContext();
  var {
    domContext,
    setFocusedIndex,
    focusedIndex,
    closeOnSelect,
    onClose,
    menuRef
  } = menu;
  var ref = useRef(null);
  var id = "menuitem-" + useId();
  /**
   * Register the menuitem's node into the domContext
   */

  var index = useDescendant({
    element: ref.current,
    context: domContext,
    disabled: isDisabled,
    focusable: isFocusable
  });
  var onMouseEnter = useCallback(() => {
    if (isDisabled) return;
    setFocusedIndex(index);
  }, [setFocusedIndex, index, isDisabled]);
  var onMouseMove = useCallback(() => {
    if (document.activeElement !== ref.current) {
      onMouseEnter();
    }
  }, [onMouseEnter]);
  var onMouseLeave = useCallback(() => {
    if (isDisabled) return;
    setFocusedIndex(-1);
  }, [setFocusedIndex, isDisabled]);
  var onClick = useCallback(event => {
    onClickProp == null ? void 0 : onClickProp(event);
    /**
     * Close menu and parent menu's if `closeOnSelect` is set to `true`
     */

    if (closeOnSelect) {
      onClose();
    }
  }, [onClose, onClickProp, closeOnSelect]);
  var isFocused = index === focusedIndex;
  var trulyDisabled = isDisabled && !isFocusable;
  useUpdateEffect(() => {
    if (isFocused && !trulyDisabled) {
      if (ref.current) {
        focus(ref.current);
      }
    } else {
      if (document.activeElement !== menuRef.current) {
        var _menuRef$current;

        (_menuRef$current = menuRef.current) == null ? void 0 : _menuRef$current.focus();
      }
    }
  }, [isFocused, trulyDisabled, menuRef]);
  var tabbable = useClickable({
    onClick,
    onMouseEnter,
    onMouseMove,
    onMouseLeave,
    ref,
    isDisabled,
    isFocusable
  });
  return _extends({}, htmlProps, tabbable, {
    className: cx("chakra-menu__menuitem", htmlProps.className),
    id,
    role: "menuitem",
    tabIndex: isFocused ? 0 : -1
  });
}
export function useMenuOption(props) {
  var {
    onClick,
    isDisabled,
    isFocusable,
    type = "radio",
    isChecked
  } = props,
      rest = _objectWithoutPropertiesLoose(props, ["onMouseOut", "onClick", "isDisabled", "isFocusable", "type", "isChecked"]);

  var ownProps = useMenuItem({
    isDisabled,
    isFocusable,
    onClick
  });
  return _extends({}, rest, ownProps, {
    className: cx("chakra-menu__menuitem-option", rest.className),
    role: "menuitem" + type,
    "aria-checked": isChecked
  });
}
export function useMenuOptionGroup(props) {
  var {
    children,
    type = "radio",
    value: valueProp,
    defaultValue,
    onChange
  } = props,
      htmlProps = _objectWithoutPropertiesLoose(props, ["children", "type", "value", "defaultValue", "onChange"]);

  var isRadio = type === "radio";
  var fallback = isRadio ? "" : [];
  var [value, setValue] = useControllableState({
    defaultValue: defaultValue != null ? defaultValue : fallback,
    value: valueProp,
    onChange
  });
  var handleChange = useCallback(selectedValue => {
    if (type === "radio" && isString(value)) {
      setValue(selectedValue);
    }

    if (type === "checkbox" && isArray(value)) {
      var nextValue = value.includes(selectedValue) ? removeItem(value, selectedValue) : addItem(value, selectedValue);
      setValue(nextValue);
    }
  }, [value, setValue, type]);
  var validChildren = getValidChildren(children);
  var clones = validChildren.map(child => {
    /**
     * We've added an internal `id` to each `MenuItemOption`,
     * let's use that for type-checking.
     *
     * We can't rely on displayName or the element's type since
     * they can be changed by the user.
     */
    if (child.type.id !== "MenuItemOption") return child;

    var onClick = event => {
      handleChange(child.props.value);
      child.props.onClick == null ? void 0 : child.props.onClick(event);
    };

    var isChecked = type === "radio" ? child.props.value === value : value.includes(child.props.value);
    return /*#__PURE__*/cloneElement(child, {
      type,
      onClick,
      isChecked
    });
  });
  return _extends({}, htmlProps, {
    className: cx("chakra-menu__option-group", htmlProps.className),
    children: clones
  });
}
export function useMenuState() {
  var {
    isOpen,
    onClose
  } = useMenuContext();
  return {
    isOpen,
    onClose
  };
}
//# sourceMappingURL=use-menu.js.map