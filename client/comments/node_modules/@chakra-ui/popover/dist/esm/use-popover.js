function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { useBoolean, useDisclosure, useIds } from "@chakra-ui/hooks";
import { usePopper } from "@chakra-ui/popper";
import { useColorModeValue, useToken } from "@chakra-ui/system";
import { callAllHandlers, mergeRefs } from "@chakra-ui/utils";
import { useInteractOutside } from "@react-aria/interactions";
import { useCallback, useEffect, useRef } from "react";
import { useFocusOnHide, useFocusOnShow } from "./popover.utils";
var TRIGGER_TYPE = {
  click: "click",
  hover: "hover"
};
export function usePopover(props) {
  if (props === void 0) {
    props = {};
  }

  var {
    closeOnBlur = true,
    closeOnEsc = true,
    initialFocusRef,
    placement: placementProp,
    gutter,
    id,
    arrowSize,
    returnFocusOnClose = true,
    autoFocus = true,
    arrowShadowColor,
    modifiers,
    trigger = TRIGGER_TYPE.click,
    openDelay = 200,
    closeDelay = 200,
    isLazy
  } = props;
  var {
    isOpen,
    onClose,
    onOpen,
    onToggle
  } = useDisclosure(props);
  var triggerRef = useRef(null);
  var popoverRef = useRef(null);
  var isHoveringRef = useRef(false);
  var [hasHeader, setHasHeader] = useBoolean();
  var [hasBody, setHasBody] = useBoolean();
  var [triggerId, popoverId, headerId, bodyId] = useIds(id, "popover-trigger", "popover-content", "popover-header", "popover-body");
  var fallbackShadowColor = useColorModeValue("gray.200", "whiteAlpha.300");
  var shadowColor = arrowShadowColor != null ? arrowShadowColor : fallbackShadowColor;
  var arrowColor = useToken("colors", shadowColor, arrowShadowColor);
  var {
    popper,
    reference,
    arrow
  } = usePopper({
    placement: placementProp,
    gutter,
    forceUpdate: isOpen,
    arrowSize,
    arrowShadowColor: arrowColor,
    modifiers
  });
  useFocusOnHide(popoverRef, {
    autoFocus: returnFocusOnClose,
    visible: isOpen,
    focusRef: triggerRef,
    trigger
  });
  useFocusOnShow(popoverRef, {
    autoFocus: autoFocus,
    visible: isOpen,
    focusRef: initialFocusRef,
    trigger
  });
  useInteractOutside({
    ref: popoverRef,
    onInteractOutside: event => {
      var _triggerRef$current;

      if (trigger === TRIGGER_TYPE.click && closeOnBlur && !((_triggerRef$current = triggerRef.current) == null ? void 0 : _triggerRef$current.contains(event.target))) {
        onClose();
      }
    }
  });
  var getPopoverProps = useCallback(function (props, ref) {
    if (props === void 0) {
      props = {};
    }

    if (ref === void 0) {
      ref = null;
    }

    var popoverProps = _extends({}, props, {
      children: isLazy ? isOpen ? props.children : null : props.children,
      id: popoverId,
      tabIndex: -1,
      hidden: !isOpen,
      role: "dialog",
      onKeyDown: callAllHandlers(props.onKeyDown, event => {
        if (closeOnEsc && event.key === "Escape") {
          onClose();
        }
      }),
      ref: mergeRefs(popoverRef, popper.ref, ref),
      style: _extends({}, props.style, popper.style),
      "aria-labelledby": hasHeader ? headerId : undefined,
      "aria-describedby": hasBody ? bodyId : undefined
    });

    if (trigger === TRIGGER_TYPE.hover) {
      popoverProps.role = "tooltip";
      popoverProps.onMouseEnter = callAllHandlers(props.onMouseEnter, () => {
        isHoveringRef.current = true;
      });
      popoverProps.onMouseLeave = callAllHandlers(props.onMouseLeave, () => {
        isHoveringRef.current = false;
        setTimeout(onClose, closeDelay);
      });
    }

    return popoverProps;
  }, [popoverId, isOpen, isLazy, popper.ref, popper.style, hasHeader, headerId, hasBody, bodyId, trigger, closeOnEsc, onClose, closeDelay]);
  var getArrowProps = useCallback(function (props, ref) {
    if (props === void 0) {
      props = {};
    }

    if (ref === void 0) {
      ref = null;
    }

    return _extends({}, props, {
      ref: mergeRefs(arrow.ref, ref),
      style: _extends({}, props.style, arrow.style)
    });
  }, [arrow.ref, arrow.style]);
  var openTimeout = useRef();
  var closeTimeout = useRef();
  var getTriggerProps = useCallback(function (props, ref) {
    if (props === void 0) {
      props = {};
    }

    if (ref === void 0) {
      ref = null;
    }

    var triggerProps = _extends({}, props, {
      id: triggerId,
      ref: mergeRefs(triggerRef, reference.ref, ref),
      "aria-haspopup": "dialog",
      "aria-expanded": isOpen,
      "aria-controls": popoverId
    });

    if (trigger === TRIGGER_TYPE.click) {
      triggerProps.onClick = callAllHandlers(props.onClick, onToggle);
    }

    if (trigger === TRIGGER_TYPE.hover) {
      /**
       * Any content that shows on pointer hover should also show on keyboard focus.
       * Consider focus and blur to be the `hover` for keyboard users.
       *
       * @see https://www.w3.org/WAI/WCAG21/Understanding/content-on-hover-or-focus.html
       */
      triggerProps.onFocus = callAllHandlers(props.onFocus, onOpen);
      triggerProps.onBlur = callAllHandlers(props.onBlur, onClose);
      /**
       * Any content that shows on hover or focus must be dismissible.
       * This case pressing `Escape` will dismiss the popover
       */

      triggerProps.onKeyDown = callAllHandlers(props.onKeyDown, event => {
        if (event.key === "Escape") {
          onClose();
        }
      });
      triggerProps.onMouseEnter = callAllHandlers(props.onMouseEnter, () => {
        isHoveringRef.current = true;
        openTimeout.current = window.setTimeout(onOpen, openDelay);
      });
      triggerProps.onMouseLeave = callAllHandlers(props.onMouseLeave, () => {
        isHoveringRef.current = false;

        if (openTimeout.current) {
          clearTimeout(openTimeout.current);
          openTimeout.current = undefined;
        }

        closeTimeout.current = window.setTimeout(() => {
          if (isHoveringRef.current === false) {
            onClose();
          }
        }, closeDelay);
      });
    }

    return triggerProps;
  }, [openDelay, closeDelay, isOpen, onToggle, popoverId, reference.ref, triggerId, trigger, onOpen, onClose]);
  useEffect(() => {
    return () => {
      if (openTimeout.current) {
        clearTimeout(openTimeout.current);
      }

      if (closeTimeout.current) {
        clearTimeout(closeTimeout.current);
      }
    };
  }, []);
  return {
    isOpen,
    onClose,
    headerId,
    hasHeader,
    setHasHeader,
    bodyId,
    hasBody,
    setHasBody,
    getArrowProps,
    getTriggerProps,
    getPopoverProps
  };
}
//# sourceMappingURL=use-popover.js.map